<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4"><Item class="ModuleScript"><Properties><string name="Name">MainModule</string><ProtectedString name="Source">-- Conglomeration
-- See https://Conglomeration.github.io/About for more information.

-- @license MIT
-- MIT License (&lt;https://astolfodev.mit-license.org/&gt;)
--
-- Copyright © 2021 AstolfoDev &lt;AstolfoDev@wafflepowered.com&gt;, Mokiy &lt;mokiy@wafflepowered.com&gt;
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

-- @minified
-- @generated
-- @source https://github.com/Conglomeration/Lua
-- @version 0.1.2-alpha.1

local f=require;local l=math;local n=bit or bit32;local a=error;local t=table;local c=string;local r=pairs;local s=setmetatable;local e=print;local u=tonumber;local d=ipairs;local o=(getfenv or function()return _ENV end)()local e={["searchers"]={[2]=function(n)a("Module not bundled: "..n)end}}if _VERSION=="Luau"then f=function(...)return e["searchers"][2](...)()end;l=s({["mod"]=l.fmod},{__index=o.math})end;do local e=e.searchers or e.loaders;local g=e[2]e[2]=function(b)local n={["util"]=function()local e={}e.forEach=function(n,o)for e,n in r(n)do o(n,e)end end;e.split_fast=function(o,n)if n==nil then n='%s'end;local e={}for n in c.gmatch(o,'([^'..n..']+)')do t.insert(e,n)end;return e end;e.split=function(o,n)n=n or'%s'local e={}for o,n in c.gmatch(o,'([^'..n..']*)('..n..'?)')do t.insert(e,o)if n==''then return e end end end;return e end,["Parsers"]=function()local e=f('util')local o=f('CFrameSerializer')local n=function(e,n,o)return{[0]=e:lower(),[1]=o,[2]=n}end;local n={n('nil',function()end,function()return''end),n('String',function(n)return n end,function(n)return n end),n('Number',function(n)return tostring(n)end,function(n)return u(n)end),n('function',function(n)warn('Unable to encode functions. Encoding functions will not be added in a future version.\nPlease implement your own lua bytecode parser and use a string to transmit this data.\nReturning nothing')return''end,function(n)warn('Unable to parse functions. Might be added in a future version. Returning empty function')return function()a('Cannot parse functions yet. Please try again later',2)end end),n('UserData',function()a('Cannot parse UserData - Try adding a parser/encoder to Conglomeration for this specific type')end,function()a('Cannot encode UserData - Try adding a parser/encoder to Conglomeration for this specific type')end),n('UDim',function(n)return n.Scale..'\6'..n.Offset end,function(n)local n=e.split_fast(n,'\6')return UDim.new(n[1],n[2])end),n('UDim2',function(n)return n.X.Scale..'\6'..n.Y.Scale..'\6'..n.X.Offset..'\6'..n.Y.Offset end,function(n)local n=e.split_fast(n,'\6')return UDim2.new(n[1],n[2],n[3],n[4])end),n('Vector3',function(n)return n.X..'\6'..n.Y..'\6'..n.Z end,function(n)local n=e.split_fast(n,'\6')return Vector3.new(n[1],n[2],n[3])end),n('Vector2',function(n)return n.X..'\6'..n.Y end,function(n)local n=e.split_fast(n,'\6')return Vector2.new(n[1],n[2])end),n('CFrame',function(n)return o:EncodeCFrame(n)end,function(n)return o:DecodeCFrame(n)end)}return n end,["Base64"]=function()local u={}local o={'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','0','1','2','3','4','5','6','7','8','9','+','/'}local e={}for o,n in d(o)do e[n]=o-1 end;local f='='local function d(n)return o[n+1]end;local function r(n)return e[n]end;function u.encode(e)local a={e:byte(i,#e)}local e={}local r=1;while r&lt;=#a-2 do local l=0;local o=n.blshift(a[r],16)o=n.band(o,16711680)l=n.bor(l,o)o=n.blshift(a[r+1],8)o=n.band(o,65280)l=n.bor(l,o)o=n.band(a[r+2],255)l=n.bor(l,o)o=n.blogic_rshift(l,18)o=n.band(o,63)e[#e+1]=d(o)o=n.blogic_rshift(l,12)o=n.band(o,63)e[#e+1]=d(o)o=n.blogic_rshift(l,6)o=n.band(o,63)e[#e+1]=d(o)o=n.band(l,63)e[#e+1]=d(o)r=r+3 end;if#a%3==1 then local l=n.blshift(a[r],16)l=n.band(l,16711680)local o=n.blogic_rshift(l,18)o=n.band(o,63)e[#e+1]=d(o)o=n.blogic_rshift(l,12)o=n.band(o,63)e[#e+1]=d(o)e[#e+1]=f;e[#e+1]=f elseif#a%3==2 then local l=0;local o=n.blshift(a[r],16)o=n.band(o,16711680)l=n.bor(l,o)o=n.blshift(a[r+1],8)o=n.band(o,65280)l=n.bor(l,o)o=n.blogic_rshift(l,18)o=n.band(o,63)e[#e+1]=d(o)o=n.blogic_rshift(l,12)o=n.band(o,63)e[#e+1]=d(o)o=n.blogic_rshift(l,6)o=n.band(o,63)e[#e+1]=d(o)e[#e+1]=f end;return t.concat(e)end;function u.decode(t)local i=#t;if f then i=t:find(f,1,true)or i+1;i=i-1 end;assert(i&gt;0,'Invalid input, cannot decode a padded string with no bytes: '..tostring(t))local l={}local e=1;while e&lt;=i-3 do local a=0;local o=r(t:sub(e,e))o=n.blshift(o,18)a=n.bor(a,o)e=e+1;o=r(t:sub(e,e))o=n.blshift(o,12)a=n.bor(a,o)e=e+1;o=r(t:sub(e,e))o=n.blshift(o,6)a=n.bor(a,o)e=e+1;o=r(t:sub(e,e))a=n.bor(a,o)e=e+1;o=n.blogic_rshift(a,16)o=n.band(o,255)l[#l+1]=o;o=n.blogic_rshift(a,8)o=n.band(o,255)l[#l+1]=o;o=n.band(a,255)l[#l+1]=o end;if i%4==2 then local a=0;local o=r(t:sub(e,e))o=n.blshift(o,18)a=n.bor(a,o)e=e+1;o=r(t:sub(e,e))o=n.blshift(o,12)a=n.bor(a,o)e=e+1;o=n.blogic_rshift(a,16)o=n.band(o,255)l[#l+1]=o elseif i%4==3 then local a=0;local o=r(t:sub(e,e))o=n.blshift(o,18)a=n.bor(a,o)e=e+1;o=r(t:sub(e,e))o=n.blshift(o,12)a=n.bor(a,o)e=e+1;o=r(t:sub(e,e))o=n.blshift(o,6)a=n.bor(a,o)e=e+1;o=n.blogic_rshift(a,16)o=n.band(o,255)l[#l+1]=o;o=n.blogic_rshift(a,8)o=n.band(o,255)l[#l+1]=o elseif i%4==1 then a('Invalid length input string, extra character: '..tostring(t:sub(e,e)))end;return c.char(unpack(l))end;do local function r(n)if n-l.floor(n)&gt;0 then a('trying to use bitwise operation on non-integer!')end end;local function e(o)r(o)if o&lt;0 then return e(n.bnot(l.abs(o))+1)end;local e={}local n=1;while o&gt;0 do local l=l.mod(o,2)if l==1 then e[n]=1 else e[n]=0 end;o=(o-l)/2;n=n+1 end;return e end;local function a(o)local l=t.getn(o)local n=0;local e=1;for l=1,l do n=n+o[l]*e;e=e*2 end;return n end;local function d(l,e)local o={}local n={}if t.getn(l)&gt;t.getn(e)then o=l;n=e else o=e;n=l end;for e=t.getn(n)+1,t.getn(o)do n[e]=0 end end;local function c(o,n)local o=e(o)local r=e(n)d(o,r)local e={}local n=l.max(t.getn(o),t.getn(r))for n=1,n do if o[n]==0 and r[n]==0 then e[n]=0 else e[n]=1 end end;return a(e)end;local function i(o,n)local r=e(o)local o=e(n)d(r,o)local e={}local n=l.max(t.getn(r),t.getn(o))for n=1,n do if r[n]==0 or o[n]==0 then e[n]=0 else e[n]=1 end end;return a(e)end;local function o(n)local n=e(n)local e=l.max(t.getn(n),32)for e=1,e do if n[e]==1 then n[e]=0 else n[e]=1 end end;return a(n)end;local function f(n,r)local o=e(n)local e=e(r)d(o,e)local r={}local n=l.max(t.getn(o),t.getn(e))for n=1,n do if o[n]~=e[n]then r[n]=1 else r[n]=0 end end;return a(r)end;local function d(n,t)r(n)local e=0;if n&lt;0 then n=o(l.abs(n))+1;e=2147483648 end;for o=1,t do n=n/2;n=c(l.floor(n),e)end;return l.floor(n)end;local function u(n,e)r(n)if n&lt;0 then n=o(l.abs(n))+1 end;for e=1,e do n=n/2 end;return l.floor(n)end;local function t(n,e)r(n)if n&lt;0 then n=o(l.abs(n))+1 end;for e=1,e do n=n*2 end;return i(n,4294967295)end;local function l(e,n)local o=c(o(e),o(n))local n=c(e,n)local n=i(n,o)return n end;n={bnot=o,band=i,bor=c,bxor=f,brshift=d,blshift=t,bxor2=l,blogic_rshift=u,tobits=e,tonumb=a}end;return u end,["typeof"]=function()local n=getfenv or function()return _ENV end;local n=n().typeof or n().type or function()a('Type/Typeof is undefined. Please define it before loading Conglomeration')end;typeof=function(...)return n(...):lower()end;if typeof''~='string'then a('Typeof returns invalid type')end;return typeof end,["CFrameSerializer"]=function()local function o(n)local e=n-n%1;if l.abs(n-e)&lt;.01 then return e else return c.format('%.7f',n)end end;local function _(n)for l,e in r(n)do n[l]=o(e)end;return n end;local function a(n)local l={n:GetComponents()}local e,o=0,0;for n=4,12 do local n=l[n]if n==-1 or n==1 then o=o+1 elseif n==0 or n==-0 then e=e+1 end end;return e==6 and o==3 end;local function e(o)for e,n in r(Enum.NormalId:GetEnumItems())do local e=Vector3.FromNormalId(n)local e=e:Dot(o)if e==1 then return n.Value end end;return-1 end;local function E(n)local e=l.floor(n/6)%3;local n=n%3;return e~=n end;local function g(n)if not a(n)then return-1 end;local o=e(n.RightVector)local n=e(n.UpVector)local n=6*o+n;if not E(n)then return-1 end;return n end;local function D(n)local t,r,c,a;local e,s,h,u,n,d,i,f,o=select(4,n:GetComponents())local b=e+n+o;if b&gt;0 then local e=l.sqrt(1+b)local n=.5/e;t=e/2;r=(f-d)*n;c=(h-i)*n;a=(u-s)*n else local b=l.max(e,n,o)if b==e then local e=l.sqrt(1+e-n-o)local n=.5/e;t=(f-d)*n;r=e/2;c=(u+s)*n;a=(h+i)*n elseif b==n then local e=l.sqrt(1-e+n-o)local n=.5/e;t=(h-i)*n;r=(u+s)*n;c=e/2;a=(f+d)*n elseif b==o then local e=l.sqrt(1-e-n+o)local n=.5/e;t=(u-s)*n;r=(h+i)*n;c=(f+d)*n;a=e/2 end end;local n={r,c,a,t}return _(n)end;local o={}local l=game:GetService('HttpService')function o:EncodeCFrame(e,t)local n=e.Position;local o={n.X,n.Y,n.Z}local n={}n.p=_(o)local o=g(e)if o&gt;=0 then n.o=o else n.m=D(e)end;if not t then n=l:JSONEncode(n)end;return n end;function o:DecodeCFrame(n,e)local n=e and n or l:JSONDecode(n)local e=n.p;for n,o in r(e)do e[n]=u(o)end;if n.m then local a,l,e=t.unpack(e)local n=n.m;for o,e in r(n)do n[o]=u(e)end;return CFrame.new(a,l,e,t.unpack(n))elseif n.o then local o=Vector3.new(t.unpack(e))local n=n.o;if E(n)then local e=n/6;local n=n%6;local e=Vector3.FromNormalId(e)local n=Vector3.FromNormalId(n)return CFrame.fromMatrix(o,e,n)end end end;return o end}if n[b]then return n[b]else return g(b)end end end;local i=f('typeof')local _=f('util')local s=f('Parsers')local b=f('Base64')local d='STANDARD-0.1.0'local o=0;local n={['HEADER_BEGIN']='\1',['END_HEADER_FIELD']='\a',['DATA_NAME']='\3',['DATA_TYPE']='\4',['DATA_LENGTH']='\5',['DATA_LAST']='\v',['DATA_BEGIN']='\6',['FORMAT_VERSION_BEGIN']='\b',['FORMAT_VERSION_END']='\t'}if o~=0 then d='DEBUGOUT.'..o..'-'..d;if o==1 then for e in r(n)do n[e]='\n['..e..']'end elseif o==2 then for e in r(n)do n[e]='\n- hcode-'..e..': 'end end end;for o,e in r(n)do n[e]=o end;local h=function(e)for o,n in r(s)do if n[0]==e then return n end end;a('No parser found for datatype '..e)end;local f=function(e)local n=n;if o&gt;0 then local o={}for l,n in r(n)do o[l]=c.gsub(n,'\n','')e=e:gsub('\n','')end;n=o end;local o=n.FORMAT_VERSION_BEGIN..d..n.FORMAT_VERSION_END;if not e:sub(1,#o)==o then a('Incompatible Data Format (Header Mismatch)')end;e=c.sub(e,#o+1,#e)local r={}local n=function(i)local l=({e:find(n.DATA_BEGIN)})[2]if not l then a('Cannot find DATA_BEGIN ('..n.DATA_BEGIN..')')end;local o=c.sub(e,1,l)local a=function(e)if not e then a('INTERNAL: !hc')end;local l=n.END_HEADER_FIELD;local n=o;local o=({n:find(e)})[1]if not o then a('Cannot find hc: '..e,2)end;n=c.sub(n,o+1)local e=({n:find(l)})[1]if not e then a('Cannot find end-hc',2)end;n=c.sub(n,1,e-1)return n end;local o={}o.Name=b.decode(a(n.DATA_NAME))o.Type=a(n.DATA_TYPE)o.Length=u(a(n.DATA_LENGTH))o.__isLastChunk=a(n.DATA_LAST)=='true'o.Data=c.sub(e,l+1,l+o.Length)if i then t.insert(r,o)end;e=c.sub(e,l+o.Length,#e)return o end;local e=n()if not e.Name=='\1________checkIntegrety'then a('Invalid Integrety Check Chunk!\nSpec requires 1st chunk to be an integrety chunk')end;if not e.__isLastChunk then local e={__isLastChunk=false}repeat e=n(true)until e.__isLastChunk end;return r end;local u=function(n)local e=h(n.Type)local e=e[1]return e(n.Data)end;local e=function(n)local n=f(n)local e={}for o,n in r(n)do e[n.Name]=u(n)end;return e end;local l=function(e,o)if not e then a('No name specified')end;if i(e)~='string'then a('Name is not a string')end;if c.find(e,n.END_HEADER_FIELD)then a('Name cannot contain the symbol '..n.END_HEADER_FIELD)end;e=b.encode(e)local l=i(o)local n=h(l)local t=n[2]local n={}n.Name=e;n.Type=l;n.Data=t(o)n.Length=#n.Data;return n end;local e=function(a)local o=''local e=function(...)local n={...}if#n&gt;1 then return t.concat({...},'')else return n[1]end end;local e=function(o,t)local l=n.HEADER_BEGIN;local e=function(...)l=l..e(...)end;e(n.DATA_NAME,o.Name,n.END_HEADER_FIELD)e(n.DATA_TYPE,o.Type)e(n.END_HEADER_FIELD)e(n.DATA_LENGTH,o.Length,n.END_HEADER_FIELD)e(n.DATA_LAST,tostring(t),n.END_HEADER_FIELD)e(n.DATA_BEGIN,o.Data)return l end;for l,n in r(a)do if l==#a then o=o..e(n,true)else o=o..e(n,false)end end;return n.FORMAT_VERSION_BEGIN..d..n.FORMAT_VERSION_END..e(l('\1________checkIntegrety','works'))..o end;local n=function(o)local n={}for o,e in r(o)do t.insert(n,l(o,e))end;return e(n)end;s.table={[0]='table',[1]=function(n)local n=f(n)local e={}for o,n in r(n)do e[n.Name]=u(n)end;return e end,[2]=function(n)local o={}for n,e in r(n)do if i(n)~='string'and i(n)~='number'then a('Only string/number-based keys are allowed for tables!')end;t.insert(o,l(tostring(n),e))end;return e(o)end}local n={}n.__Parsers=s;n.__ENCODING={['\1']=e,['\2']=l}n.__DECODING={['\1']=f,['\2']=u}n.__Util=_;return n</ProtectedString><boolean name="cgl">true</boolean><string name="copyright">Copyright (c) 2021 AstolfoDev. Licensed under the MIT License.</string><int64 name="SourceAssetId">1</int64></Properties></Item></roblox>